<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>My first three.js app</title>
    <style>
      body {
        margin: 0;
      }
    </style>
  </head>
  <body>
    <div id="stats"></div>
    <div id="main"></div>
  </body>
</html>
<script src="https://cdnjs.cloudflare.com/ajax/libs/stats.js/r16/Stats.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/17.2.0/Tween.min.js"></script>
<script type="module">
  import * as THREE from 'https://cdn.skypack.dev/three@0.135.0'
  import { OrbitControls } from 'https://cdn.skypack.dev/three@0.135.0/examples/jsm/controls/OrbitControls.js'
  import { GLTFLoader } from 'https://cdn.skypack.dev/three@0.135.0/examples/jsm/loaders/GLTFLoader.js'
  import { Lensflare, LensflareElement } from 'https://cdn.skypack.dev/three@0.135.0/examples/jsm/objects/Lensflare.js'

  let scene, renderer, camera
  let cameraControl, stats
  let sphereLightMesh, pointLight
  let mixers = []
  let creeperObj
  let tween, tweenBack
  let time
  let rotateAngle = 0
  let invert = 1
  let modelMesh
  let keysPressed = {}

  class Creeper {
    constructor() {
      // 宣告頭、身體、腳幾何體大小
      const headGeo = new THREE.BoxGeometry(4, 4, 4)
      const bodyGeo = new THREE.BoxGeometry(4, 8, 2)
      const footGeo = new THREE.BoxGeometry(2, 3, 2)

      // 苦力怕臉部貼圖
      const headMap = new THREE.TextureLoader().load('../assets/img/creeper_face.png')
      // 苦力怕皮膚貼圖
      const skinMap = new THREE.TextureLoader().load('../assets/img/creeper.png')

      // 身體與腳的材質設定
      const skinMat = new THREE.MeshPhongMaterial({
        map: skinMap, // 皮膚貼圖
      })

      // 準備頭部與臉的材質
      const headMaterials = []
      for (let i = 0; i < 6; i++) {
        let map

        if (i === 4) map = headMap
        else map = skinMap

        headMaterials.push(new THREE.MeshPhongMaterial({ map: map }))
      }

      // 頭
      this.head = new THREE.Mesh(headGeo, headMaterials)
      this.head.position.set(0, 6, 0)
      this.head.rotation.y = 0.5 // 稍微的擺頭

      // 身體
      this.body = new THREE.Mesh(bodyGeo, skinMat)
      this.body.position.set(0, 0, 0)

      // 四隻腳
      this.foot1 = new THREE.Mesh(footGeo, skinMat)
      this.foot1.position.set(-1, -5.5, 2)
      this.foot2 = this.foot1.clone() // 剩下三隻腳都複製第一隻的 Mesh
      this.foot2.position.set(-1, -5.5, -2)
      this.foot3 = this.foot1.clone()
      this.foot3.position.set(1, -5.5, 2)
      this.foot4 = this.foot1.clone()
      this.foot4.position.set(1, -5.5, -2)

      // 將四隻腳組合為一個 group
      this.feet = new THREE.Group()
      this.feet.add(this.foot1)
      this.feet.add(this.foot2)
      this.feet.add(this.foot3)
      this.feet.add(this.foot4)

      // 將頭、身體、腳組合為一個 group
      this.creeper = new THREE.Group()
      this.creeper.add(this.head)
      this.creeper.add(this.body)
      this.creeper.add(this.feet)

      // 苦力怕投影設定，利用 traverse 遍歷各個子元件設定陰影
      this.creeper.traverse(function (object) {
        if (object instanceof THREE.Mesh) {
          object.castShadow = true
          object.receiveShadow = true
        }
      })
    }
  }

  //  添加光線
  function addLight() {
    // 設置環境光提供輔助柔和白光
    const ambientLight = new THREE.AmbientLight(0x404040)
    scene.add(ambientLight)

    const spotLight = new THREE.PointLight(0xffffff, 2)
    spotLight.position.set(0, 600, 0)

    spotLight.castShadow = true

    spotLight.shadow.mapSize.width = 1024
    spotLight.shadow.mapSize.height = 1024

    //  光源輔助器
    // var shadowHelper = new THREE.CameraHelper(spotLight.shadow.camera)
    // scene.add(shadowHelper)
    spotLight.shadow.camera.near = 0.1
    spotLight.shadow.camera.far = 100000
    spotLight.shadow.camera.fov = 90

    scene.add(spotLight)

    var textureFlare2 = new THREE.TextureLoader().load('./20200630103311828.png')
    var textureFlare0 = new THREE.TextureLoader().load('./20200630103304387.png')
    var lensFlare = new Lensflare()
    lensFlare.addElement(new LensflareElement(textureFlare0, 1000, 0.0, new THREE.Color(0xffffff)))
    lensFlare.addElement(new LensflareElement(textureFlare2, 60, 0.6, new THREE.Color(0xffff00)))
    lensFlare.addElement(new LensflareElement(textureFlare2, 70, 0.7, new THREE.Color(0x00ffff)))
    lensFlare.addElement(new LensflareElement(textureFlare2, 120, 0.9, new THREE.Color(0x00ff00)))
    lensFlare.addElement(new LensflareElement(textureFlare2, 70, 1.0, new THREE.Color(0x0000ff)))
    lensFlare.position.copy(spotLight.position)
    // scene.add(lensFlare)
  }

  // 生成苦力怕並加到場景
  function createCreeper() {
    creeperObj = new Creeper()
    scene.add(creeperObj.creeper)
  }

  //  生成鳳凰
  function createPhoenix() {
    const loader = new GLTFLoader()
    loader.load(
      './models/phoenix/scene.gltf',
      function (gltf) {
        camera.position.set(-15, 105, 0) // 相機位置
        scene.add(camera)
        gltf.scene.scale.set(0.01, 0.01, 0.01)
        gltf.scene.position.set(camera.position.x + 10, camera.position.y - 5, camera.position.z)
        gltf.scene.rotation.copy(camera.rotation)
        scene.add(gltf.scene) // 將模型引入three
        cameraControl.target.set(gltf.scene.position.x, gltf.scene.position.y + 3, gltf.scene.position.z)
        gltf.scene.traverse(function (node) {
          if (node.isMesh) {
            node.castShadow = true
            node.receiveShadow = true
          }
        })
        modelMesh = gltf.scene
        // 調用動畫
        const mixer = new THREE.AnimationMixer(gltf.scene)
        mixer.clipAction(gltf.animations[0]).play()
        mixers.push(mixer)
      },
      undefined,
      function (error) {
        console.error(error)
      }
    )
  }

  // 建立粒子系統(雪花)
  function createPoints() {
    const texture = new THREE.TextureLoader().load('./20107572piCtGLYX4z.png')
    const material = new THREE.PointsMaterial({
      size: 50,
      map: texture,
      blending: THREE.AdditiveBlending,
      depthTest: false,
      transparent: true,
      opacity: 0.7,
    })

    let vertices = []
    for (let i = 0; i < 100000; i++) {
      const x = THREE.Math.randInt(-50000, 50000)
      const y = THREE.Math.randInt(-50000, 50000)
      const z = THREE.Math.randInt(-50000, 50000)

      const point = new THREE.Vector3(x, y, z)
      vertices.push(point)
    }
    const geometry = new THREE.BufferGeometry().setFromPoints(vertices)
    const points = new THREE.Points(geometry, material)
    scene.add(points)
  }

  //  創建天空場景
  function createSkybox() {
    let materialArray = []
    let texture_ft = new THREE.TextureLoader().load('./penguins/yonder_ft.jpg')
    let texture_bk = new THREE.TextureLoader().load('./penguins/yonder_bk.jpg')
    let texture_up = new THREE.TextureLoader().load('./penguins/yonder_up.jpg')
    let texture_dn = new THREE.TextureLoader().load('./penguins/yonder_dn.jpg')
    let texture_rt = new THREE.TextureLoader().load('./penguins/yonder_rt.jpg')
    let texture_lf = new THREE.TextureLoader().load('./penguins/yonder_lf.jpg')

    materialArray.push(new THREE.MeshBasicMaterial({ map: texture_ft }))
    materialArray.push(new THREE.MeshBasicMaterial({ map: texture_bk }))
    materialArray.push(new THREE.MeshBasicMaterial({ map: texture_up }))
    materialArray.push(new THREE.MeshBasicMaterial({ map: texture_dn }))
    materialArray.push(new THREE.MeshBasicMaterial({ map: texture_rt }))
    materialArray.push(new THREE.MeshBasicMaterial({ map: texture_lf }))

    for (let i = 0; i < 6; i++) materialArray[i].side = THREE.BackSide
    let skyboxGeo = new THREE.BoxGeometry(100000, 100000, 100000)
    let skybox = new THREE.Mesh(skyboxGeo, materialArray)
    scene.add(skybox)
  }

  function initStats() {
    const stats = new Stats()
    stats.setMode(0)
    document.getElementById('stats').appendChild(stats.domElement)
    return stats
  }

  const clock = new THREE.Clock()

  function init() {
    scene = new THREE.Scene()

    camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.1, 100000)
    // camera.position.set(-15, 105, 0) // 相機位置

    let axes = new THREE.AxesHelper(20)
    scene.add(axes)

    stats = initStats()

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true })
    renderer.setSize(window.innerWidth, window.innerHeight)
    renderer.shadowMap.enabled = true
    renderer.setClearColor(0x111111)
    renderer.shadowMap.type = 2 // THREE.PCFSoftShadowMap

    cameraControl = new OrbitControls(camera, renderer.domElement)
    cameraControl.enableDamping = true // 啟用阻尼效果
    cameraControl.dampingFactor = 0.25 // 阻尼系數

    createSkybox()
    createPhoenix()

    createPoints()
    addLight()

    // createCreeper()

    //  監聽鍵盤事件

    document.addEventListener('keyup', onKeyUp)
    document.addEventListener('keypress', onKeyPress)
    document.addEventListener('keydown', onKeyDown)

    // 將渲染器的 DOM 綁到網頁上
    document.getElementById('main').appendChild(renderer.domElement)
  }

  function attack() {
    console.log(123)
    const geometry = new THREE.BoxGeometry(2, 2, 2)
    const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 })
    const cube = new THREE.Mesh(geometry, material)
    scene.add(cube)
    cube.position.copy(modelMesh.position)
    new TWEEN.Tween(cube.position)
  }

  //  控制移動
  function moveHandler() {
    let movement
    const speed = 50
    const rotateSpeed = 0.05

    TWEEN.removeAll()

    if (JSON.stringify(keysPressed) !== '{}') {
      new TWEEN.Tween(scene)
        .to(movement, 600) //walks 2 meters a second * the distance
        .onUpdate(() => {
          let matrix
          const direction = new THREE.Vector3()
          const direction2 = new THREE.Vector3()

          const calRotate = (radiu) => {
            modelMesh.rotateY(radiu)
            const thetaX = Math.acos((camera.position.x - modelMesh.position.x) / 10)
            const thetaZ = Math.asin((camera.position.z - modelMesh.position.z) / 10)
            let theta = thetaX
            if (thetaZ > 0) {
              theta = 2 * Math.PI - thetaX
            }
            camera.position.set(
              modelMesh.position.x + 10 * Math.cos(theta + radiu),
              modelMesh.position.y + 5,
              modelMesh.position.z - 10 * Math.sin(theta + radiu)
            )
          }

          if (keysPressed['w']) {
            camera.getWorldDirection(direction)
            camera.position.addScaledVector({ x: direction.x, y: 0, z: direction.z }, speed)
            modelMesh.position.copy(camera.position)
            modelMesh.updateMatrix()
            modelMesh.translateX(10)
            modelMesh.translateY(-5)
          }

          if (keysPressed['s']) {
            camera.getWorldDirection(direction)
            camera.position.addScaledVector({ x: direction.x, y: 0, z: direction.z }, speed * -1)
            modelMesh.position.copy(camera.position)
            modelMesh.updateMatrix()
            modelMesh.translateX(10)
            modelMesh.translateY(-5)
          }

          if (keysPressed['a']) {
            calRotate(rotateSpeed)
          }

          if (keysPressed['d']) {
            calRotate(rotateSpeed * -1)
          }
          cameraControl.target.set(modelMesh.position.x, modelMesh.position.y + 3, modelMesh.position.z)
        })
        .start()
    }
  }

  //  鬆開按鍵
  function onKeyUp(event) {
    delete keysPressed[event.key]
  }

  //  按住按鈕
  function onKeyPress(event) {
    keysPressed[event.key] = true
  }

  //  按下按鈕
  function onKeyDown(event) {
    if (event.key === ' ') {
      attack()
    }
  }

  function animations() {
    var delta = clock.getDelta()
    for (var i = 0; i < mixers.length; i++) {
      // 重復播放動畫
      mixers[i].update(delta)
    }
  }

  function render() {
    cameraControl.update() // 需設定 update

    animations()

    TWEEN.update()
    requestAnimationFrame(render)

    moveHandler()
    renderer.render(scene, camera)
    stats.update()
  }

  // 監聽螢幕寬高變化來做簡單 RWD 設定
  window.addEventListener('resize', function () {
    camera.aspect = window.innerWidth / window.innerHeight
    camera.updateProjectionMatrix()
    renderer.setSize(window.innerWidth, window.innerHeight)
  })

  init()

  render()
</script>
<style>
  #stats {
    position: absolute;
    top: 10px;
    width: 100%;
    text-align: center;
    z-index: 100;
    display: block;
  }
</style>
